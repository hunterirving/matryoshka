<!DOCTYPE html>
<html lang="en" data-theme="gak"> <!-- update to change default theme -->
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- favicon -->
	<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸª†</text></svg>">

	<title>todo</title>
	<style>
		/* custom colors */
		:root {
			--coconut: #ffffff;
			--licorice: #000000;
			--wasabi: #ccff00;
			--eggplant: #7700ff;

			--murk: #8e9918;
			--tadpole: #27350f;
			--lilypad: #6f8823;
			--reed: #4a5d23;

			--pollen: #f4a127;
			--loam: #5a352b;
			--chlorophyll: #5aa83b;
			--terracotta: #b15c2e;

			--wheat: #d2c3a3;
			--earth: #4a3c31;
			--pumpkin: #cb7c52;
			--tobacco: #7d6c55;

			--moss: #20302f;
			--goat-milk: #d8d3c9;
			--burl: #231f20;
			--flame: #c63728;

			--soot: #181a1b;
			--smoke: #e8e6e3;
			--ash: #252829;
			--cinder: #ff5532;

			--blue-raspberry: #0458b3;
			--cola: #1e1515;
			--bubblegum: #e11761;
			--taffy: #eaeaea;
		}

		/* custom fonts */
		@font-face {
			font-family: BasteleurMoonlight;
			src: url('resources/fonts/Basteleur-Moonlight.ttf') format('truetype');
		}

		/* themes */
		:root[data-theme="gak"] {
			--background: var(--coconut);
			--text: var(--licorice);
			--highlight: var(--wasabi);
			--accent: var(--eggplant);
		}

		:root[data-theme="swamp"] {
			--background: var(--murk);
			--text: var(--tadpole);
			--highlight: var(--lilypad);
			--accent: var(--reed);
		}

		:root[data-theme="sunflower"] {
			--background: var(--pollen);
			--text: var(--loam);
			--highlight: var(--chlorophyll);
			--accent: var(--terracotta);
		}

		:root[data-theme="harvest"] {
			--background: var(--wheat);
			--text: var(--earth);
			--highlight: var(--pumpkin);
			--accent: var(--tobacco);
		}

		:root[data-theme="medieval"] {
			--background: var(--moss);
			--text: var(--goat-milk);
			--highlight: var(--burl);
			--accent: var(--flame);
			& input[type="text"] {
				font-family: BasteleurMoonlight;
			}
		}
		
		:root[data-theme="woodstove"] {
			--background: var(--soot);
			--text: var(--smoke);
			--highlight: var(--ash);
			--accent: var(--cinder);
			& input[type="text"] {
				font-family: BasteleurMoonlight;
			}
			.parent-task {
				--text: var(--cinder)
			}
		}

		:root[data-theme="sugar"] {
			--background: var(--cola);
			--text: var(--taffy);
			--highlight: var(--blue-raspberry);
			--accent: var(--bubblegum);

			.checkbox-label {
				border-radius: 10px;
			}
			.active {
				border-radius: 30px 0px 0px 30px;
			}
			.custom-checkbox:checked + .checkbox-label::before {
				display: none;
			}
			& input[type="text"] {
				text-shadow: 1px 1px 1px var(--cola);
			}
		}

		/* interface styling */
		@keyframes shake {
			0% { transform: translateX(0); }
			20% { transform: translateX(3px); }
			40% { transform: translateX(-3px); }
			60% { transform: translateX(3px); }
			80% { transform: translateX(-3px); }
			100% { transform: translateX(0); }
		}
		.shake {
			animation: shake 0.25s ease-out;
		}
		body {
			font-family: Arial, sans-serif;
			max-width: 800px;
			margin: 0 auto;
			padding: 20px;
			background-color: var(--background);
			color: var(--text);
		}
		ul {
			list-style-type: none;
			padding-left: 20px;
		}
		input[type="text"] {
			border: none;
			background: transparent;
			font-size: 1.17em;
			font-weight: bold;
			width: calc(100% - 30px);
			margin-left: 5px;
			padding: 5px;
			color: var(--text);
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}
		input[type="text"]:focus {
			outline: none;
		}
		input[type="text"]::selection {
			background-color: var(--accent);
			color: var(--background);
		}
		.task-container {
			display: flex;
			align-items: center;
			margin: 5px 0;
			padding-left: 11px;
			padding-top: 4px;
			padding-bottom: 4px;
		}
		.active {
			background-color: var(--highlight);
		}
		.parent-task {
			font-size: 1.5em;
			font-weight: bold;
		}
		#breadcrumbs {
			font-size: 24px;
			margin-bottom: 10px;
			color: var(--text);
			user-select: none;
		}
		.custom-checkbox {
			display: none;
		}
		.checkbox-label {
			display: inline-block;
			width: 20px;
			height: 20px;
			background-color: var(--background);
			border: 2px solid var(--accent);
			position: relative;
			cursor: pointer;
			box-sizing: border-box;
			border-radius: 4px;
		}
		.custom-checkbox:checked + .checkbox-label {
			background-color: var(--accent);
		}
		.custom-checkbox:checked + .checkbox-label::before {
			content: '';
			position: absolute;
			left: 6px;
			top: 2px;
			width: 5px;
			height: 10px;
			border: solid var(--background);
			border-width: 0 2px 2px 0;
			transform: rotate(45deg);
			box-sizing: border-box;
		}
		.custom-checkbox:indeterminate + .checkbox-label::before {
			content: '';
			position: absolute;
			left: 25%;
			right: 25%;
			top: 50%;
			height: 2px;
			background-color: var(--accent);
			transform: translateY(-50%);
		}
	</style>
	<script>
		document.addEventListener('click', function(e) {
			if (!e.target.closest('.task-container')) {
				const activeTask = document.querySelector('.task-container.active');
				if (activeTask) {
					const taskInput = activeTask.querySelector('input[type="text"]');
					taskInput.focus();
				} else {
					selectFirstSubtask();
				}
			}
		});
		document.addEventListener('DOMContentLoaded', function() {
			const appContainer = document.getElementById('app-container');
			let rootTask = loadTasksFromLocalStorage();
			let currentTask = rootTask;
			let taskPath = [currentTask];
			let lastSubtaskDownArrowReleased = false;
			let saveTimer = null;
			let currentThemeIndex = 0;
			let isF2Pressed = false;
			let themes = [];

			function handleSave(e) {
				if ((e.metaKey || e.ctrlKey) && e.key === 's') {
					e.preventDefault();
					saveTaskTreeToFile();
				}
			}

			function saveTaskTreeToFile() {
				const serializedTasks = serializeTaskTree(taskPath[0]);
				const rootTaskName = taskPath[0].text || 'Untitled';
				const date = new Date();
				const fileName = `${rootTaskName} - ${date.toLocaleString('default', { month: 'short' }).toLowerCase()} ${date.getDate()}, '${date.getFullYear().toString().slice(-2)}.txt`;
				
				const blob = new Blob([serializedTasks], { type: 'text/plain' });
				const url = URL.createObjectURL(blob);
				
				const a = document.createElement('a');
				a.href = url;
				a.download = fileName;
				a.click();
				
				URL.revokeObjectURL(url);
			}

			function handleOpen(e) {
				if ((e.metaKey || e.ctrlKey) && e.key === 'o') {
					e.preventDefault();
					openTaskTreeFromFile();
				}
			}

			function openTaskTreeFromFile() {
				const input = document.createElement('input');
				input.type = 'file';
				input.accept = '.txt';
				input.onchange = function(event) {
					const file = event.target.files[0];
					const reader = new FileReader();
					reader.onload = function(e) {
						try {
							const newRootTask = deserializeTaskTree(e.target.result);
							if (confirm('Are you sure you want to overwrite the existing task tree?')) {
								rootTask = newRootTask;
								currentTask = rootTask;
								taskPath = [currentTask];
								renderCurrentView();
								saveTasksToLocalStorage();
							}
						} catch (error) {
							alert(`Error importing task tree: ${error.message}`);
						}
					};
					reader.readAsText(file);
				};
				input.click();
			}

			function scheduleSave() {
				if (saveTimer) {
					clearTimeout(saveTimer);
				}
				saveTimer = setTimeout(saveTasksToLocalStorage, 1000);
			}

			function saveTasksToLocalStorage() {
				const serializedTasks = serializeTaskTree(taskPath[0]);
				localStorage.setItem('taskTree', serializedTasks);
				saveTimer = null;
			}

			function serializeTaskTree(task, depth = 0) {
				const indentation = '\t'.repeat(depth);
				let status = task.state === 0 ? '_' : (task.state === 1 ? 'x' : '?');
				let serialized = `${indentation}${status} ${task.text}\n`;
				
				for (let subtask of task.subtasks) {
					serialized += serializeTaskTree(subtask, depth + 1);
				}
				
				return serialized;
			}

			function loadTasksFromLocalStorage() {
				const savedTasks = localStorage.getItem('taskTree');
				if (savedTasks) {
					console.log('%cloaded tasks from local storage:', "color: green;");
					console.log(savedTasks);
					return deserializeTaskTree(savedTasks);
				} else {
					return { id: 'root', text: 'todo', state: 0, subtasks: [{ id: Date.now(), text: '', state: 0, subtasks: [] }], selectedSubtaskId: null };
				}
			}

			function deserializeTaskTree(serialized) {
				const lines = serialized.split('\n').filter(line => line.trim() !== '');
				const root = { id: 'root', subtasks: [] };
				const stack = [{ task: root, depth: -1 }];

				for (let line of lines) {
					const depth = (line.match(/^\t*/)[0] || '').length;
					const status = line[depth];
					const text = line.slice(depth + 2);
					
					const newTask = {
						id: depth === 0 ? 'root' : Date.now() + Math.random(),
						text: text,
						state: status === '_' ? 0 : (status === 'x' ? 1 : 2),
						subtasks: [],
						selectedSubtaskId: null
					};
					
					while (stack.length > 1 && stack[stack.length - 1].depth >= depth) {
						stack.pop();
					}
					
					if (depth === 0) {
						Object.assign(root, newTask);
					} else {
						stack[stack.length - 1].task.subtasks.push(newTask);
					}
					stack.push({ task: newTask, depth: depth });
				}
				
				return root;
			}

			const keyHandler = {
				backspace: {
					canDelete: true,
					blocked: false
				},
				enter: {
					canAdd: true,
					blocked: false
				},
				arrowDown: {
					canAdd: true,
					blocked: false
				},
				shiftEnter: {
					pressed: false
				},
				shiftRight: {
					pressed: false
				},
				shiftLeft: {
					pressed: false
				}
			};

			function createTaskElement(task, isParentTask = false) {
				const taskContainer = document.createElement('div');
				taskContainer.className = 'task-container';
				taskContainer.dataset.id = task.id;
				if (isParentTask) taskContainer.classList.add('parent-task');

				const checkbox = document.createElement('input');
				checkbox.type = 'checkbox';
				checkbox.className = 'custom-checkbox';
				checkbox.id = `checkbox-${task.id}`;
				updateCheckboxState(checkbox, task.state);
				checkbox.addEventListener('click', (e) => {
					e.preventDefault();
					toggleTaskState(task);
				});

				const checkboxLabel = document.createElement('label');
				checkboxLabel.className = 'checkbox-label';
				checkboxLabel.setAttribute('for', `checkbox-${task.id}`);

				const taskInput = document.createElement('input');
				taskInput.type = 'text';
				taskInput.value = task.text;
				taskInput.setAttribute('autocomplete', 'off');

				taskInput.addEventListener('mousedown', function(e) {
					e.stopPropagation();
				});

				const keydownHandler = function(e) {
					if (e.key === 'Backspace') {
						if (keyHandler.backspace.blocked) {
							e.preventDefault();
							return;
						}
						if (taskInput.value === '' && keyHandler.backspace.canDelete) {
							e.preventDefault();
							if (task !== taskPath[0]) {
								keyHandler.backspace.blocked = true;
								if (task === currentTask) {
									deleteCurrentParentTask();
								} else {
									deleteSubtask(task);
								}
							} else {
								// Attempting to delete root task
								applyShakeAnimation(task.id);
							}
						} else if (taskInput.value !== '') {
							keyHandler.backspace.canDelete = false;
						}
					} else if (e.key === 'Enter' && !e.shiftKey) {
						if (keyHandler.enter.blocked) {
							e.preventDefault();
							return;
						}
						if (keyHandler.enter.canAdd) {
							e.preventDefault();
							keyHandler.enter.blocked = true;
							addNewSubtask(currentTask, task);
						}
					} else if (e.key === 'ArrowDown' && !e.shiftKey) {
						if (keyHandler.arrowDown.blocked) {
							e.preventDefault();
							return;
						}
						if (isLastSubtask(task) && lastSubtaskDownArrowReleased && task !== currentTask) {
							e.preventDefault();
							keyHandler.arrowDown.blocked = true;
							addNewSubtask(currentTask, task);
							lastSubtaskDownArrowReleased = false;
						} else {
							handleKeyDown(e, task);
						}
					} else {
						handleKeyDown(e, task);
					}
				};

				const keyupHandler = function(e) {
					if (e.key === 'Backspace') {
						keyHandler.backspace.canDelete = true;
						keyHandler.backspace.blocked = false;
					} else if (e.key === 'Enter') {
						keyHandler.enter.canAdd = true;
						keyHandler.enter.blocked = false;
						keyHandler.shiftEnter.pressed = false;
					} else if (e.key === 'ArrowDown') {
						keyHandler.arrowDown.canAdd = true;
						keyHandler.arrowDown.blocked = false;
						if (isLastSubtask(task)) {
							lastSubtaskDownArrowReleased = true;
						} else {
							lastSubtaskDownArrowReleased = false;
						}
					} else if (e.key === 'ArrowRight') {
						keyHandler.shiftRight.pressed = false;
					} else if (e.key === 'ArrowLeft') {
						keyHandler.shiftLeft.pressed = false;
					}
				};

				taskInput.addEventListener('keydown', keydownHandler);
				taskInput.addEventListener('keyup', keyupHandler);
				taskInput.addEventListener('keydown', handleCopyAndCut);
				appContainer.addEventListener('focusin', function(e) {
					if (e.target.tagName === 'INPUT' && e.target.type === 'text') {
						document.querySelectorAll('input[type="text"]').forEach(input => {
							if (input !== e.target) {
								placeCursorAtBeginning(input);
							}
						});
					}
				});

				taskInput.addEventListener('input', () => {
					task.text = taskInput.value;
					if (task === currentTask) {
						updatePageTitle(task);
					}
					scheduleSave();
				});

				taskInput.addEventListener('focus', () => setActiveTask(taskInput, task));

				taskContainer.appendChild(checkbox);
				taskContainer.appendChild(checkboxLabel);
				taskContainer.appendChild(taskInput);

				return taskContainer;
			}

			function generateBreadcrumbs(rootTask, currentPath, selectedTaskId) {
				let breadcrumbs = '';
				let currentTask = rootTask;
				let currentDepth = 0;

				for (let i = 0; i < currentPath.length - 1; i++) {
					breadcrumbs += 'â—‹ ';
					currentTask = currentTask.subtasks.find(t => t.id === currentPath[i + 1].id);
				}

				breadcrumbs += 'â— ';
				currentDepth = currentPath.length - 1;

				if (selectedTaskId !== currentTask.id) {
					let selectedTask = currentTask.subtasks.find(t => t.id === selectedTaskId);
					
					if (selectedTask) {
						function calculateMaxDepth(task, depth) {
							if (task.subtasks.length === 0) return depth;
							return Math.max(...task.subtasks.map(st => calculateMaxDepth(st, depth + 1)));
						}

						let maxDepth = calculateMaxDepth(selectedTask, currentDepth + 1);

						for (let i = currentDepth + 1; i < maxDepth; i++) {
							breadcrumbs += 'â—‹ ';
						}
					}
				}

				return breadcrumbs.trim();
			}

			function updateCheckboxState(checkbox, state) {
				checkbox.checked = state === 1;
				checkbox.indeterminate = state === 2;
			}

			function toggleTaskState(task) {
				if (task.state === 1) {
					if (task.subtasks.length === 0 || !task.subtasks.every(t => t.state === 1)) {
						task.state = 0;
						updateSubtasksState(task, 0);
						
						const parent = findParentTask(task);
						if (parent) {
							updateTaskAndAncestors(parent);
						}
						
						renderCurrentView();
						selectAndFocusTask(task);
						scheduleSave();
					} else {
						// disallow unchecking and play a 'shake' animation
						applyShakeAnimation(task.id);
					}
				} else {
					task.state = 1;
					updateSubtasksState(task, 1);
					
					const parent = findParentTask(task);
					if (parent) {
						updateTaskAndAncestors(parent);
					}
					
					renderCurrentView();
					selectAndFocusTask(task);
					scheduleSave();
				}
			}

			function applyShakeAnimation(taskId) {
				const checkbox = document.querySelector(`.task-container[data-id="${taskId}"] .checkbox-label`);
				if (checkbox) {
					checkbox.classList.add('shake');
					setTimeout(() => {
						checkbox.classList.remove('shake');
					}, 250); // Remove class after animation completes
				}
			}

			function recalculateTaskState(task) {
				if (task.subtasks.length === 0) {
					return task.state; // If no subtasks, keep current state
				}
				const anyUnchecked = task.subtasks.some(t => t.state === 0);
				const allCheckedOrIndeterminate = task.subtasks.every(t => t.state === 1 || t.state === 2);
				
				if (allCheckedOrIndeterminate) {
					return 1; // Checked
				} else if (anyUnchecked) {
					return 0; // Unchecked
				}
			}

			function updateTaskAndAncestors(task) {
				const newState = recalculateTaskState(task);
				if (task.state !== newState) {
					const oldState = task.state;
					task.state = newState;
					
					// If the task changed from checked to unchecked, update its descendants
					if (oldState === 1 && newState === 0) {
						updateSubtasksState(task, 0);
					}
					
					const parent = findParentTask(task);
					if (parent) {
						updateTaskAndAncestors(parent);
					}
				}
			}

			function updateSubtasksState(task, state) {
				task.subtasks.forEach(subtask => {
					if (subtask.state !== 1) {  // Only update if the subtask is not checked
						if (state === 1) {
							subtask.state = subtask.state === 0 ? 2 : subtask.state;
						} else if (state === 0) {
							subtask.state = 0;
						}
						if (subtask.subtasks.length > 0) {
							updateSubtasksState(subtask, state);
						}
					}
				});
			}

			function deleteSubtask(subtask) {
				const parentTask = taskPath[taskPath.length - 1];
				const index = parentTask.subtasks.findIndex(t => t.id === subtask.id);

				if (parentTask.id === 'root' && parentTask.subtasks.length === 1) {
					// Disallow deletion of the root task's sole remaining child
					applyShakeAnimation(subtask.id);
					return;
				}

				// Delete the subtask
				parentTask.subtasks = parentTask.subtasks.filter(t => t.id !== subtask.id);

				// Recalculate parent state and propagate changes
				updateTaskAndAncestors(parentTask);

				if (parentTask.subtasks.length === 0 && taskPath.length > 1) {
					navigateToParentTask();
				} else {
					renderCurrentView();
					if (parentTask.subtasks.length > 0) {
						const targetIndex = Math.max(0, index - 1);
						selectAndFocusTask(parentTask.subtasks[targetIndex]);
					} else {
						selectAndFocusTask(parentTask);
					}
				}
				scheduleSave();
			}

			function deleteCurrentParentTask() {
				if (taskPath.length <= 1) return; // Don't delete root task

				const currentParentTask = taskPath[taskPath.length - 1];
				const grandparentTask = taskPath[taskPath.length - 2];

				// Check if we're trying to delete the sole child of the root
				if (grandparentTask.id === 'root' && grandparentTask.subtasks.length === 1) {
					// Don't allow deletion of the sole child of root
					applyShakeAnimation(currentParentTask.id);
					return;
				}

				const index = grandparentTask.subtasks.findIndex(t => t.id === currentParentTask.id);

				grandparentTask.subtasks = grandparentTask.subtasks.filter(t => t.id !== currentParentTask.id);
				updateTaskAndAncestors(grandparentTask);

				taskPath.pop(); // Remove the deleted task from the path
				currentTask = grandparentTask;

				if (grandparentTask.subtasks.length === 0 && taskPath.length > 1) {
					// If we've just deleted the last subtask, navigate up another level
					navigateToParentTask();
				} else {
					renderCurrentView();
					if (grandparentTask.subtasks.length > 0) {
						// Select the subtask before the deleted one, or the one after if at the start
						const targetIndex = Math.max(0, index - 1);
						selectAndFocusTask(grandparentTask.subtasks[targetIndex]);
					} else {
						selectAndFocusTask(grandparentTask);
					}
				}
			}

			function findParentTask(task) {
				for (let i = taskPath.length - 1; i >= 0; i--) {
					const potentialParent = taskPath[i];
					if (potentialParent.subtasks.some(t => t.id === task.id)) {
						return potentialParent;
					}
				}
				return null;
			}

			function handleKeyDown(e, task) {
				if (e.key === 'Enter' && e.shiftKey) {
					e.preventDefault();
					if (!keyHandler.shiftEnter.pressed) {
						keyHandler.shiftEnter.pressed = true;
						toggleTaskState(task);
					}
				} else if (e.key === 'ArrowUp' && !e.shiftKey) {
					e.preventDefault();
					navigateTasks('up');
				} else if (e.key === 'ArrowDown' && !e.shiftKey) {
					e.preventDefault();
					navigateTasks('down');
				} else if (e.key === 'ArrowUp' && e.shiftKey) {
					e.preventDefault();
					moveSubtask(task, 'up');
				} else if (e.key === 'ArrowDown' && e.shiftKey) {
					e.preventDefault();
					moveSubtask(task, 'down');
				} else if (e.key === 'ArrowRight' && e.shiftKey) {
					e.preventDefault();
					if (!keyHandler.shiftRight.pressed) {
						keyHandler.shiftRight.pressed = true;
						if (task !== currentTask) {
							navigateIntoSubtask(task);
						}
					}
				} else if (e.key === 'ArrowLeft' && e.shiftKey) {
					e.preventDefault();
					if (!keyHandler.shiftLeft.pressed) {
						keyHandler.shiftLeft.pressed = true;
						navigateToParentTask();
					}
				}
			}

			function moveSubtask(subtask, direction) {
				const parentTask = findParentTask(subtask);
				if (!parentTask) return;

				const index = parentTask.subtasks.findIndex(t => t.id === subtask.id);
				if (index === -1) return;

				if (direction === 'up' && index > 0) {
					[parentTask.subtasks[index - 1], parentTask.subtasks[index]] = [parentTask.subtasks[index], parentTask.subtasks[index - 1]];
				} else if (direction === 'down' && index < parentTask.subtasks.length - 1) {
					[parentTask.subtasks[index], parentTask.subtasks[index + 1]] = [parentTask.subtasks[index + 1], parentTask.subtasks[index]];
				}

				renderCurrentView();
				selectAndFocusTask(subtask);
				scheduleSave();
			}

			function addNewSubtask(parentTask, currentSubtask = null) {
				const newSubtask = { id: Date.now(), text: '', state: 0, subtasks: [], selectedSubtaskId: null };
				if (currentSubtask) {
					const index = parentTask.subtasks.findIndex(t => t.id === currentSubtask.id);
					parentTask.subtasks.splice(index + 1, 0, newSubtask);
				} else {
					parentTask.subtasks.push(newSubtask);
				}

				updateTaskAndAncestors(parentTask);

				renderCurrentView();
				selectAndFocusTask(newSubtask);
				scheduleSave();
			}

			function selectAndFocusTask(task) {
				const taskInput = document.querySelector(`.task-container[data-id="${task.id}"] input[type="text"]`);
				if (taskInput) {
					taskInput.focus();
					taskInput.setSelectionRange(taskInput.value.length, taskInput.value.length);
					setActiveTask(taskInput, task);
				}
			}

			function placeCursorAtBeginning(input) {
				input.setSelectionRange(0, 0);
			}

			function navigateTasks(direction) {
				const tasks = currentTask.subtasks;
				const currentElement = document.activeElement;
				const currentContainer = currentElement.closest('.task-container');
				const currentIndex = Array.from(appContainer.querySelectorAll('.task-container')).indexOf(currentContainer);

				if (direction === 'up') {
					if (currentIndex > 0) {
						const prevTask = currentIndex === 1 ? currentTask : tasks[currentIndex - 2];
						selectAndFocusTask(prevTask);
					}
				} else {
					if (currentIndex < tasks.length) {
						selectAndFocusTask(tasks[currentIndex]);
					}
				}
				lastSubtaskDownArrowReleased = false;
			}

			function navigateIntoSubtask(subtask) {
				if (subtask.subtasks.length > 0) {
					currentTask.selectedSubtaskId = subtask.id;
					taskPath.push(subtask);
					currentTask = subtask;
					updateBreadcrumbs(currentTask);
					renderCurrentView();
					const selectedSubtask = subtask.selectedSubtaskId ? 
						subtask.subtasks.find(t => t.id === subtask.selectedSubtaskId) : 
						subtask.subtasks[0];
					selectAndFocusTask(selectedSubtask);
				} else {
					addNewSubtask(subtask);
					currentTask.selectedSubtaskId = subtask.id;
					taskPath.push(subtask);
					currentTask = subtask;
					updateBreadcrumbs(currentTask);
					renderCurrentView();
					selectAndFocusTask(subtask.subtasks[0]);
				}
			}

			function navigateToParentTask() {
				if (taskPath.length > 1) {
					const currentTaskId = currentTask.id;
					taskPath.pop();
					currentTask = taskPath[taskPath.length - 1];
					updateBreadcrumbs(currentTask);
					renderCurrentView();
					const selectedSubtask = currentTask.subtasks.find(t => t.id === currentTaskId);
					if (selectedSubtask) {
						selectAndFocusTask(selectedSubtask);
					} else if (currentTask.subtasks.length > 0) {
						selectAndFocusTask(currentTask.subtasks[0]);
					} else {
						selectAndFocusTask(currentTask);
					}
					currentTask.selectedSubtaskId = currentTaskId;
				}
			}

			function setActiveTask(input, task) {
				document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));
				input.closest('.task-container').classList.add('active');
				if (task !== currentTask) {
					currentTask.selectedSubtaskId = task.id;
				}
				updateBreadcrumbs(task);
				lastSubtaskDownArrowReleased = isLastSubtask(task);
				input.focus();
			}

			function updateBreadcrumbs(selectedTask) {
				const breadcrumbsContainer = document.getElementById('breadcrumbs');
				const trail = generateBreadcrumbs(taskPath[0], taskPath, selectedTask.id);
				breadcrumbsContainer.textContent = trail;
			}

			function renderCurrentView() {
				appContainer.innerHTML = '';
				currentTask = taskPath[taskPath.length - 1];

				updateBreadcrumbs(currentTask);
				updatePageTitle(currentTask);

				const parentElement = createTaskElement(currentTask, true);
				appContainer.appendChild(parentElement);

				const subtasksList = document.createElement('ul');
				currentTask.subtasks.forEach(subtask => {
					const li = document.createElement('li');
					li.appendChild(createTaskElement(subtask));
					subtasksList.appendChild(li);
				});
				appContainer.appendChild(subtasksList);

				const parentCheckbox = parentElement.querySelector('input[type="checkbox"]');
				updateCheckboxState(parentCheckbox, currentTask.state);

				if (currentTask.selectedSubtaskId) {
					const selectedTask = currentTask.subtasks.find(t => t.id === currentTask.selectedSubtaskId);
					if (selectedTask) {
						selectAndFocusTask(selectedTask);
					} else {
						selectFirstSubtask();
					}
				} else {
					selectFirstSubtask();
				}
			}

			function selectFirstSubtask() {
				if (currentTask.subtasks.length > 0) {
					const firstSubtask = currentTask.subtasks[0];
					selectAndFocusTask(firstSubtask);
				} else {
					selectAndFocusTask(currentTask);
				}
			}

			function handleCopyAndCut(e) {
				if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'x')) {
					const activeTaskInput = document.querySelector('.task-container.active input[type="text"]');
					if (activeTaskInput) {
						e.preventDefault();

						// If there's no selection, select all text
						if (activeTaskInput.selectionStart === activeTaskInput.selectionEnd) {
							activeTaskInput.select();
						}

						// Use execCommand for copy or cut
						if (e.key === 'c') {
							document.execCommand('copy');
						} else if (e.key === 'x') {
							document.execCommand('cut');

							// Update the task object
							const taskContainer = activeTaskInput.closest('.task-container');
							const taskId = taskContainer.dataset.id;
							const task = currentTask.id === taskId ? currentTask : currentTask.subtasks.find(t => t.id === taskId);
							if (task) {
								task.text = activeTaskInput.value;
								scheduleSave();
							}
						}

						// Deselect text if we had to select all
						if (e.key === 'c' && activeTaskInput.selectionStart === 0 && activeTaskInput.selectionEnd === activeTaskInput.value.length) {
							activeTaskInput.setSelectionRange(activeTaskInput.value.length, activeTaskInput.value.length);
						}
					}
				}
			}

			function updatePageTitle(task) {
				document.title = task.text || '?';
			}

			function isLastSubtask(task) {
				const parentTask = findParentTask(task);
				if (!parentTask) return false;
				return parentTask.subtasks[parentTask.subtasks.length - 1].id === task.id;
			}

			function getThemesFromCSS() {
				const styleElement = document.querySelector('style');
				if (styleElement && styleElement.textContent) {
					const cssText = styleElement.textContent;
					const themeRegex = /:root\[data-theme="([^"]+)"\]/g;
					let match;
					while ((match = themeRegex.exec(cssText)) !== null) {
						themes.push(match[1]);
					}
				}
			}

			function cycleTheme() {
				currentThemeIndex = (currentThemeIndex + 1) % themes.length;
				const newTheme = themes[currentThemeIndex];
				document.documentElement.setAttribute('data-theme', newTheme);
				saveThemeToLocalStorage(newTheme);
			}

			function saveThemeToLocalStorage(theme) {
				localStorage.setItem('currentTheme', theme);
			}

			function setInitialTheme() {
				const savedTheme = localStorage.getItem('currentTheme');
				const defaultTheme = document.documentElement.getAttribute('data-theme');
				
				if (savedTheme && themes.includes(savedTheme)) {
					currentThemeIndex = themes.indexOf(savedTheme);
				} else if (themes.includes(defaultTheme)) {
					currentThemeIndex = themes.indexOf(defaultTheme);
				} else {
					currentThemeIndex = 0;
				}
				
				document.documentElement.setAttribute('data-theme', themes[currentThemeIndex]);
			}

			document.addEventListener('keydown', function(event) {
				if (event.key === 'F2' && !isF2Pressed) {
					event.preventDefault();
					isF2Pressed = true;
					cycleTheme();
				}
			});

			document.addEventListener('keyup', function(event) {
				if (event.key === 'F2') {
					isF2Pressed = false;
				}
			});

			document.addEventListener('keydown', handleSave);
            document.addEventListener('keydown', handleOpen);

			getThemesFromCSS();
			setInitialTheme();
			renderCurrentView();
			selectFirstSubtask();
		});
	</script>
</head>
<body>
	<div id="breadcrumbs"></div>
	<div id="app-container"></div>
</body>
</html>