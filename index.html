<!DOCTYPE html>
<html lang="en" data-theme="gak"> <!-- update to change theme -->
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🪆</text></svg>">
	<title>todo</title>
	<style>
		:root {
			--tomato-soup: #FF6347;
			--forest: #3CB371;
			--mint: #00a88a;
 
			--slime: #ccff00;
			--grape: #7700ff;
			--snow: #ffffff;
			--coal: #000000;

			--chocolate: #59311a;
			--strawberry: #ffd1dc;
			--vanilla: #f3eedc;

			--acorn: #5a352b;
			--butternut-squash: #f4a127;
			--goldenrod: #eeba30;
			--olive: #4c620c;
			--pumpkin: #e5771e;

			--primordial-soup: #8e9918;
			--clay: #58473d;
			--lichen: #b1b893;
			--amber: #b76700;
			
			--algae: #4a5d23;
			--seaweed: #2e8b57;
			--kelp: #769830;
			--spirogyra: #9acd32;
		}

		:root[data-theme="gak"] {
			--background: var(--snow);
			--text: var(--coal);
			--highlight: var(--slime);
			--accent: var(--grape);
		}

		:root[data-theme="harvest"] {
			--background: var(--goldenrod);
			--text: var(--acorn);
			--highlight: var(--butternut-squash);
			--accent: var(--olive);
		}

		body {
			font-family: Arial, sans-serif;
			max-width: 800px;
			margin: 0 auto;
			padding: 20px;
			background-color: var(--background);
			color: var(--text);
		}
		ul {
			list-style-type: none;
			padding-left: 20px;
		}
		input[type="text"] {
			border: none;
			background: transparent;
			font-size: 1.17em;
			font-weight: bold;
			width: calc(100% - 30px);
			margin-left: 5px;
			padding: 5px;
			color: var(--text);
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}
		input[type="text"]:focus {
			outline: none;
		}
		input[type="text"]::selection {
			background-color: var(--accent);
			color: var(--background);
		}
		.task-container {
			display: flex;
			align-items: center;
			margin: 5px 0;
			padding-left: 11px;
			padding-top: 4px;
			padding-bottom: 4px;
		}
		.active {
			background-color: var(--highlight);
		}
		.parent-task {
			font-size: 1.5em;
			font-weight: bold;
		}
		#breadcrumbs {
			font-size: 24px;
			margin-bottom: 10px;
			color: var(--text);
		}
		.custom-checkbox {
			display: none;
		}
		.checkbox-label {
			display: inline-block;
			width: 20px;
			height: 20px;
			background-color: var(--background);
			border: 2px solid var(--accent);
			position: relative;
			cursor: pointer;
			box-sizing: border-box;
			border-radius: 4px;
		}
		.custom-checkbox:checked + .checkbox-label {
			background-color: var(--accent);
		}
		.custom-checkbox:checked + .checkbox-label::before {
			content: '';
			position: absolute;
			left: 6px;
			top: 2px;
			width: 5px;
			height: 10px;
			border: solid var(--background);
			border-width: 0 2px 2px 0;
			transform: rotate(45deg);
			box-sizing: border-box;
		}
		.custom-checkbox:indeterminate + .checkbox-label::before {
			content: '';
			position: absolute;
			left: 25%;
			right: 25%;
			top: 50%;
			height: 2px;
			background-color: var(--accent-color);
			transform: translateY(-50%);
		}
	</style>
	<script>
		document.addEventListener('click', function(e) {
			if (!e.target.closest('.task-container')) {
				const activeTask = document.querySelector('.task-container.active');
				if (activeTask) {
					const taskInput = activeTask.querySelector('input[type="text"]');
					taskInput.focus();
				} else {
					selectFirstSubtask();
				}
			}
		});
		document.addEventListener('DOMContentLoaded', function() {
			const appContainer = document.getElementById('app-container');
			let rootTask = loadFromLocalStorage();
			let currentTask = rootTask;
			let taskPath = [currentTask];
			let lastSubtaskDownArrowReleased = false;
			let saveTimer = null;

			function scheduleSave() {
				if (saveTimer) {
					clearTimeout(saveTimer);
				}
				saveTimer = setTimeout(saveToLocalStorage, 1000);
			}

			function saveToLocalStorage() {
				const serializedTasks = serializeTaskTree(taskPath[0]);
				localStorage.setItem('taskTree', serializedTasks);
				saveTimer = null;
			}

			function serializeTaskTree(task, depth = 0) {
				const indentation = '\t'.repeat(depth);
				let status = task.state === 0 ? '_' : (task.state === 1 ? 'x' : '?');
				let serialized = `${indentation}${status} ${task.text}\n`;
				
				for (let subtask of task.subtasks) {
					serialized += serializeTaskTree(subtask, depth + 1);
				}
				
				return serialized;
			}

			function loadFromLocalStorage() {
				const savedTasks = localStorage.getItem('taskTree');
				if (savedTasks) {
					return deserializeTaskTree(savedTasks);
				} else {
					return { id: 'root', text: 'todo', state: 0, subtasks: [{ id: Date.now(), text: '', state: 0, subtasks: [] }], selectedSubtaskId: null };
				}
			}

			function deserializeTaskTree(serialized) {
				const lines = serialized.split('\n').filter(line => line.trim() !== '');
				const root = { id: 'root', subtasks: [] };
				const stack = [{ task: root, depth: -1 }];

				for (let line of lines) {
					const depth = (line.match(/^\t*/)[0] || '').length;
					const status = line[depth];
					const text = line.slice(depth + 2);
					
					const newTask = {
						id: depth === 0 ? 'root' : Date.now() + Math.random(),
						text: text,
						state: status === '_' ? 0 : (status === 'x' ? 1 : 2),
						subtasks: [],
						selectedSubtaskId: null
					};
					
					while (stack.length > 1 && stack[stack.length - 1].depth >= depth) {
						stack.pop();
					}
					
					if (depth === 0) {
						Object.assign(root, newTask);
					} else {
						stack[stack.length - 1].task.subtasks.push(newTask);
					}
					stack.push({ task: newTask, depth: depth });
				}
				
				return root;
			}

			const keyHandler = {
				backspace: {
					canDelete: true,
					blocked: false
				},
				enter: {
					canAdd: true,
					blocked: false
				},
				arrowDown: {
					canAdd: true,
					blocked: false
				},
				shiftEnter: {
					pressed: false
				},
				shiftRight: {
					pressed: false
				},
				shiftLeft: {
					pressed: false
				}
			};

			function createTaskElement(task, isParentTask = false) {
				const taskContainer = document.createElement('div');
				taskContainer.className = 'task-container';
				taskContainer.dataset.id = task.id;
				if (isParentTask) taskContainer.classList.add('parent-task');

				const checkbox = document.createElement('input');
				checkbox.type = 'checkbox';
				checkbox.className = 'custom-checkbox';
				checkbox.id = `checkbox-${task.id}`;
				updateCheckboxState(checkbox, task.state);
				checkbox.addEventListener('click', (e) => {
					e.preventDefault();
					toggleTaskState(task);
				});

				const checkboxLabel = document.createElement('label');
				checkboxLabel.className = 'checkbox-label';
				checkboxLabel.setAttribute('for', `checkbox-${task.id}`);

				const taskInput = document.createElement('input');
				taskInput.type = 'text';
				taskInput.value = task.text;

				taskInput.addEventListener('mousedown', function(e) {
					e.stopPropagation();
				});

				const keydownHandler = function(e) {
					if (e.key === 'Backspace') {
						if (keyHandler.backspace.blocked) {
							e.preventDefault();
							return;
						}
						if (taskInput.value === '' && keyHandler.backspace.canDelete) {
							e.preventDefault();
							if (task !== taskPath[0]) {
								keyHandler.backspace.blocked = true;
								if (task === currentTask) {
									deleteCurrentParentTask();
								} else {
									deleteSubtask(task);
								}
							}
						} else if (taskInput.value !== '') {
							keyHandler.backspace.canDelete = false;
						}
					} else if (e.key === 'Enter' && !e.shiftKey) {
						if (keyHandler.enter.blocked) {
							e.preventDefault();
							return;
						}
						if (keyHandler.enter.canAdd) {
							e.preventDefault();
							keyHandler.enter.blocked = true;
							addNewSubtask(currentTask, task);
						}
					} else if (e.key === 'ArrowDown' && !e.shiftKey) {
						if (keyHandler.arrowDown.blocked) {
							e.preventDefault();
							return;
						}
						if (isLastSubtask(task) && lastSubtaskDownArrowReleased && task !== currentTask) {
							e.preventDefault();
							keyHandler.arrowDown.blocked = true;
							addNewSubtask(currentTask, task);
							lastSubtaskDownArrowReleased = false;
						} else {
							handleKeyDown(e, task);
						}
					} else {
						handleKeyDown(e, task);
					}
				};

				const keyupHandler = function(e) {
					if (e.key === 'Backspace') {
						keyHandler.backspace.canDelete = true;
						keyHandler.backspace.blocked = false;
					} else if (e.key === 'Enter') {
						keyHandler.enter.canAdd = true;
						keyHandler.enter.blocked = false;
						keyHandler.shiftEnter.pressed = false;
					} else if (e.key === 'ArrowDown') {
						keyHandler.arrowDown.canAdd = true;
						keyHandler.arrowDown.blocked = false;
						if (isLastSubtask(task)) {
							lastSubtaskDownArrowReleased = true;
						} else {
							lastSubtaskDownArrowReleased = false;
						}
					} else if (e.key === 'ArrowRight') {
						keyHandler.shiftRight.pressed = false;
					} else if (e.key === 'ArrowLeft') {
						keyHandler.shiftLeft.pressed = false;
					}
				};

				taskInput.addEventListener('keydown', keydownHandler);
				taskInput.addEventListener('keyup', keyupHandler);
				taskInput.addEventListener('keydown', copyActiveTaskText);

				taskInput.addEventListener('input', () => {
					task.text = taskInput.value;
					if (task === currentTask) {
						updatePageTitle(task);
					}
					scheduleSave();
				});

				taskInput.addEventListener('focus', () => setActiveTask(taskInput, task));

				taskContainer.appendChild(checkbox);
				taskContainer.appendChild(checkboxLabel);
				taskContainer.appendChild(taskInput);

				return taskContainer;
			}

			function generateBreadcrumbs(rootTask, currentPath, selectedTaskId) {
				let breadcrumbs = '';
				let currentTask = rootTask;
				let currentDepth = 0;

				for (let i = 0; i < currentPath.length - 1; i++) {
					breadcrumbs += '○ ';
					currentTask = currentTask.subtasks.find(t => t.id === currentPath[i + 1].id);
				}

				breadcrumbs += '● ';
				currentDepth = currentPath.length - 1;

				if (selectedTaskId !== currentTask.id) {
					let selectedTask = currentTask.subtasks.find(t => t.id === selectedTaskId);
					
					if (selectedTask) {
						function calculateMaxDepth(task, depth) {
							if (task.subtasks.length === 0) return depth;
							return Math.max(...task.subtasks.map(st => calculateMaxDepth(st, depth + 1)));
						}

						let maxDepth = calculateMaxDepth(selectedTask, currentDepth + 1);

						for (let i = currentDepth + 1; i < maxDepth; i++) {
							breadcrumbs += '○ ';
						}
					}
				}

				return breadcrumbs.trim();
			}

			function updateCheckboxState(checkbox, state) {
				checkbox.checked = state === 1;
				checkbox.indeterminate = state === 2;
			}

			function toggleTaskState(task) {
				if (task.state === 1) {
					if (task.subtasks.length === 0 || !task.subtasks.every(t => t.state === 1)) {
						task.state = 0;
						if (task.subtasks.length > 0) {
							task.subtasks.forEach(subtask => {
								if (subtask.state === 2) {
									subtask.state = 0;
								}
							});
						}
					}
				} else {
					task.state = 1;
					if (task.subtasks.length > 0) {
						task.subtasks.forEach(subtask => {
							if (subtask.state === 0) {
								subtask.state = 2;
							}
						});
					}
				}
				updateParentTaskState(task);
				renderCurrentView();
				selectAndFocusTask(task);
				scheduleSave();
			}

			function updateParentTaskState(task) {
				const parent = findParentTask(task);
				if (parent) {
					const allChecked = parent.subtasks.every(t => t.state === 1);
					const anyUnchecked = parent.subtasks.some(t => t.state === 0);

					if (allChecked) {
						parent.state = 1;
					} else if (anyUnchecked) {
						parent.state = 0;
					}

					updateParentTaskState(parent);
				}
			}

			function updateSubtasksState(task, state) {
				task.subtasks.forEach(subtask => {
					subtask.state = state;
					if (subtask.subtasks.length > 0) {
						updateSubtasksState(subtask, state);
					}
				});
			}

			function findParentTask(task) {
				for (let i = taskPath.length - 1; i >= 0; i--) {
					const potentialParent = taskPath[i];
					if (potentialParent.subtasks.some(t => t.id === task.id)) {
						return potentialParent;
					}
				}
				return null;
			}

			function handleKeyDown(e, task) {
				if (e.key === 'Enter' && e.shiftKey) {
					e.preventDefault();
					if (!keyHandler.shiftEnter.pressed) {
						keyHandler.shiftEnter.pressed = true;
						toggleTaskState(task);
					}
				} else if (e.key === 'ArrowUp' && !e.shiftKey) {
					e.preventDefault();
					navigateTasks('up');
				} else if (e.key === 'ArrowDown' && !e.shiftKey) {
					e.preventDefault();
					navigateTasks('down');
				} else if (e.key === 'ArrowUp' && e.shiftKey) {
					e.preventDefault();
					moveSubtask(task, 'up');
				} else if (e.key === 'ArrowDown' && e.shiftKey) {
					e.preventDefault();
					moveSubtask(task, 'down');
				} else if (e.key === 'ArrowRight' && e.shiftKey) {
					e.preventDefault();
					if (!keyHandler.shiftRight.pressed) {
						keyHandler.shiftRight.pressed = true;
						if (task !== currentTask) {
							navigateIntoSubtask(task);
						}
					}
				} else if (e.key === 'ArrowLeft' && e.shiftKey) {
					e.preventDefault();
					if (!keyHandler.shiftLeft.pressed) {
						keyHandler.shiftLeft.pressed = true;
						placeCursorAtBeginning(e.target);
						navigateToParentTask();
					}
				}
			}

			function moveSubtask(subtask, direction) {
				const parentTask = findParentTask(subtask);
				if (!parentTask) return;

				const index = parentTask.subtasks.findIndex(t => t.id === subtask.id);
				if (index === -1) return;

				if (direction === 'up' && index > 0) {
					[parentTask.subtasks[index - 1], parentTask.subtasks[index]] = [parentTask.subtasks[index], parentTask.subtasks[index - 1]];
				} else if (direction === 'down' && index < parentTask.subtasks.length - 1) {
					[parentTask.subtasks[index], parentTask.subtasks[index + 1]] = [parentTask.subtasks[index + 1], parentTask.subtasks[index]];
				}

				renderCurrentView();
				selectAndFocusTask(subtask);
				scheduleSave();
			}

			function addNewSubtask(parentTask, currentSubtask = null) {
				const newSubtask = { id: Date.now(), text: '', state: 0, subtasks: [], selectedSubtaskId: null };
				if (currentSubtask) {
					const index = parentTask.subtasks.findIndex(t => t.id === currentSubtask.id);
					parentTask.subtasks.splice(index + 1, 0, newSubtask);
				} else {
					parentTask.subtasks.push(newSubtask);
				}

				parentTask.state = 0;
				parentTask.subtasks.forEach(subtask => {
					if (subtask.state === 2) {
						subtask.state = 0;
					}
				});

				renderCurrentView();
				selectAndFocusTask(newSubtask);
				scheduleSave();
			}

			function selectAndFocusTask(task) {
				const taskInput = document.querySelector(`.task-container[data-id="${task.id}"] input[type="text"]`);
				if (taskInput) {
					taskInput.focus();
					taskInput.setSelectionRange(taskInput.value.length, taskInput.value.length);
					setActiveTask(taskInput, task);
				}
			}

			function placeCursorAtBeginning(taskInput) {
				taskInput.setSelectionRange(0, 0);
			}

			function deleteSubtask(subtask) {
				const parentTask = taskPath[taskPath.length - 1];
				const index = parentTask.subtasks.findIndex(t => t.id === subtask.id);

				if (parentTask.id === 'root' && parentTask.subtasks.length === 1) {
					return;
				}

				parentTask.subtasks = parentTask.subtasks.filter(t => t.id !== subtask.id);
				updateParentTaskState(parentTask);

				if (parentTask.subtasks.length === 0 && taskPath.length > 1) {
					navigateToParentTask();
				} else {
					renderCurrentView();
					if (parentTask.subtasks.length > 0) {
						const targetIndex = Math.max(0, index - 1);
						selectAndFocusTask(parentTask.subtasks[targetIndex]);
					} else {
						selectAndFocusTask(parentTask);
					}
				}
				scheduleSave();
			}

			function deleteCurrentParentTask() {
				if (taskPath.length <= 1) return; // Don't delete root task

				const currentParentTask = taskPath[taskPath.length - 1];
				const grandparentTask = taskPath[taskPath.length - 2];

				// Check if we're trying to delete the sole child of the root
				if (grandparentTask.id === 'root' && grandparentTask.subtasks.length === 1) {
					return; // Don't allow deletion of the sole child of root
				}

				const index = grandparentTask.subtasks.findIndex(t => t.id === currentParentTask.id);

				grandparentTask.subtasks = grandparentTask.subtasks.filter(t => t.id !== currentParentTask.id);
				updateParentTaskState(grandparentTask);

				taskPath.pop(); // Remove the deleted task from the path
				currentTask = grandparentTask;

				if (grandparentTask.subtasks.length === 0 && taskPath.length > 1) {
					// If we've just deleted the last subtask, navigate up another level
					navigateToParentTask();
				} else {
					renderCurrentView();
					if (grandparentTask.subtasks.length > 0) {
						// Select the subtask before the deleted one, or the one after if at the start
						const targetIndex = Math.max(0, index - 1);
						selectAndFocusTask(grandparentTask.subtasks[targetIndex]);
					} else {
						selectAndFocusTask(grandparentTask);
					}
				}
			}

			function navigateTasks(direction) {
				const tasks = currentTask.subtasks;
				const currentElement = document.activeElement;
				const currentContainer = currentElement.closest('.task-container');
				const currentIndex = Array.from(appContainer.querySelectorAll('.task-container')).indexOf(currentContainer);

				placeCursorAtBeginning(currentElement);

				if (direction === 'up') {
					if (currentIndex > 0) {
						const prevTask = currentIndex === 1 ? currentTask : tasks[currentIndex - 2];
						selectAndFocusTask(prevTask);
					}
				} else {
					if (currentIndex < tasks.length) {
						selectAndFocusTask(tasks[currentIndex]);
					}
				}
				lastSubtaskDownArrowReleased = false;
			}

			function navigateIntoSubtask(subtask) {
				if (subtask.subtasks.length > 0) {
					currentTask.selectedSubtaskId = subtask.id;
					taskPath.push(subtask);
					currentTask = subtask;
					updateBreadcrumbs(currentTask);
					renderCurrentView();
					const selectedSubtask = subtask.selectedSubtaskId ? 
						subtask.subtasks.find(t => t.id === subtask.selectedSubtaskId) : 
						subtask.subtasks[0];
					selectAndFocusTask(selectedSubtask);
				} else {
					addNewSubtask(subtask);
					currentTask.selectedSubtaskId = subtask.id;
					taskPath.push(subtask);
					currentTask = subtask;
					updateBreadcrumbs(currentTask);
					renderCurrentView();
					selectAndFocusTask(subtask.subtasks[0]);
				}
			}

			function navigateToParentTask() {
				if (taskPath.length > 1) {
					const currentTaskId = currentTask.id;
					taskPath.pop();
					currentTask = taskPath[taskPath.length - 1];
					updateParentTaskState(currentTask);
					updateBreadcrumbs(currentTask);
					renderCurrentView();
					const selectedSubtask = currentTask.subtasks.find(t => t.id === currentTaskId);
					if (selectedSubtask) {
						selectAndFocusTask(selectedSubtask);
					} else if (currentTask.subtasks.length > 0) {
						selectAndFocusTask(currentTask.subtasks[0]);
					} else {
						selectAndFocusTask(currentTask);
					}
					currentTask.selectedSubtaskId = currentTaskId;
				}
			}

			function setActiveTask(input, task) {
				document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));
				input.closest('.task-container').classList.add('active');
				if (task !== currentTask) {
					currentTask.selectedSubtaskId = task.id;
				}
				updateBreadcrumbs(task);
				lastSubtaskDownArrowReleased = isLastSubtask(task);
				input.focus();
			}

			function updateBreadcrumbs(selectedTask) {
				const breadcrumbsContainer = document.getElementById('breadcrumbs');
				const trail = generateBreadcrumbs(taskPath[0], taskPath, selectedTask.id);
				breadcrumbsContainer.textContent = trail;
			}

			function renderCurrentView() {
				appContainer.innerHTML = '';
				currentTask = taskPath[taskPath.length - 1];

				updateBreadcrumbs(currentTask);
				updatePageTitle(currentTask);

				const parentElement = createTaskElement(currentTask, true);
				appContainer.appendChild(parentElement);

				const subtasksList = document.createElement('ul');
				currentTask.subtasks.forEach(subtask => {
					const li = document.createElement('li');
					li.appendChild(createTaskElement(subtask));
					subtasksList.appendChild(li);
				});
				appContainer.appendChild(subtasksList);

				const parentCheckbox = parentElement.querySelector('input[type="checkbox"]');
				updateCheckboxState(parentCheckbox, currentTask.state);

				if (currentTask.selectedSubtaskId) {
					const selectedTask = currentTask.subtasks.find(t => t.id === currentTask.selectedSubtaskId);
					if (selectedTask) {
						selectAndFocusTask(selectedTask);
					} else {
						selectFirstSubtask();
					}
				} else {
					selectFirstSubtask();
				}
			}

			function selectFirstSubtask() {
				if (currentTask.subtasks.length > 0) {
					const firstSubtask = currentTask.subtasks[0];
					selectAndFocusTask(firstSubtask);
				} else {
					selectAndFocusTask(currentTask);
				}
			}

			function copyActiveTaskText(e) {
				// Check if the key combination is Ctrl+C (Windows) or Cmd+C (Mac)
				if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
					const activeTaskInput = document.querySelector('.task-container.active input[type="text"]');
					if (activeTaskInput) {
						// Check if there's a selection within the active task input
						const selectedText = activeTaskInput.value.substring(activeTaskInput.selectionStart, activeTaskInput.selectionEnd);
						
						const textToCopy = selectedText || activeTaskInput.value;
						
						e.preventDefault(); // Prevent default copy behavior
						navigator.clipboard.writeText(textToCopy);
					}
				}
			}

			function updatePageTitle(task) {
				document.title = task.text || '?';
			}

			function isLastSubtask(task) {
				const parentTask = findParentTask(task);
				if (!parentTask) return false;
				return parentTask.subtasks[parentTask.subtasks.length - 1].id === task.id;
			}

			renderCurrentView();
			selectFirstSubtask();
		});
	</script>
</head>
<body>
	<div id="breadcrumbs"></div>
	<div id="app-container"></div>
</body>
</html>